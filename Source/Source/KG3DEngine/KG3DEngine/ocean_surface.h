#ifndef _OCEAN_WAVE_H
#define _OCEAN_WAVE_H

#include <D3DX9.h>

#ifndef FFTW_ENABLE_FLOAT
#define FFTW_ENABLE_FLOAT
#endif

#include "fftw/rfftw.h"

// Height map resolution: for wavy ocean.
//#define HeightMapSize				256//128
//#define RIPPLE_MAP_SIZE				128

// Ocean grid setting
#define XN_LESS						3
#define YN_LESS						3
#define BICOLOR_TEX_SIZE			256

// Threshold for discarding a patch
#define OCEAN_MINIM_PIXELS			300

#define FOAM_TEX_SIZE				256

#define METER2INCH					39.37f	// 1m = 39.37inch
#define INCH2METER					0.0254f	// 1inch = 0.0254m

class KG3DTerrainRender;

struct ocean_vertex
{
	D3DXVECTOR3 p;	// vertex position
	D3DXVECTOR2 t;	// texture
};

struct OceanParameter
{
	// Notice: XN and YN present the patch number (not vertex number) along the X and Y direction,
	// e.g., with a 64x64 displacement map, both XN and YN are 64, so that there are 65 vertices
	// along X and Y axes. The extra 1 vertex ensures the seamless tiling.
	int HeightMapSize;
	INT MeshXN, MeshYN;
	INT TileX;
	INT TileY;
	FLOAT UnitLength;

	// Simulation properties
	FLOAT TimeScale;
	FLOAT WaveAmplitude;
	D3DXVECTOR2 WindDir;
	FLOAT WindVelocity;
	FLOAT WindDependency;
	FLOAT ChoppyScale;

	// Shading properties
	D3DXVECTOR4 ShallowColor;
	D3DXVECTOR4 DeepColor;
	FLOAT ColorBlendFactor;
	FLOAT ReflectScale;
	FLOAT ReflFresnel;
	FLOAT RefrFresnel;
	FLOAT ReflDistort;
	FLOAT RefrDistort;
};

enum OceanBufferType
{
	Buffer_None			= 0,
	Buffer_HeightMap	= 1,
	Buffer_GradientMap	= 2,
	Buffer_FoldingMap	= 3,
};

class OceanSurface
{
public:
	OceanSurface();
	~OceanSurface();

	OceanParameter m_params;

	// -------------------------- Initialization & simulation routines -------------------------

	// Initialize the vector field.
	// wlen_x: width of wave tile, in meters
	// wlen_y: length of wave tile, in meters
	void initHeightMap(OceanParameter& params);

	// do view frustum test at CPU side
//	void updateVisibilityArray(FD3DRenderInterface* RI);
	// update ocean wave when tick arrives.
	void updateHeightMap();
	// generate surface normal and folding value from height map.
	void updateGradientMap();

	// create a triangle strip mesh for ocean surface.
	void createSurfaceMesh();
	// create color/fresnel lookup table.
	void createBicolorMap();

	// ---------------------------------- CPU simulation data ---------------------------------

	// Initial vector field generated by Phillips spectrum & Gauss distribution.
	// H0
	// Should be [HeightMapSize+1][HeightMapSize+1], but for 16-byte alignment, changed to [HeightMapSize+1][HeightMapSize+4]
	fftw_complex* m_pHeightField0;

	// Vector field updated each frame
	// H(t)
	// Should be [HeightMapSize/2][HeightMapSize+1], but for 16-byte alignment, changed to [HeightMapSize/2][HeightMapSize+4]
	fftw_complex* m_pHeightField;
	
	// Angular frequency
	// Should be [HeightMapSize+1][HeightMapSize+1], but for 16-byte alignment, changed to [HeightMapSize+1][HeightMapSize+4]
	float* omega;

	// Height & choppy buffer, [(HeightMapSize+2)*HeightMapSize]
	float* m_Dz;
	// Choppy buffer
	float* m_Dx;
	float* m_Dy;

	// Double buffers for multi-thread, [(HeightMapSize+2)*HeightMapSize];
	//float* m_Dx2;
	//float* m_Dy2;
	//float* m_Dz2;

	// FFTW variable
	rfftwnd_plan g_fft_plan;

	// ---------------------------------- GPU shading data ---------------------------------

	// D3D objects
	LPDIRECT3DDEVICE9 m_pd3dDevice;
	// Simple LOD implementation
	LPDIRECT3DVERTEXBUFFER9 m_pOceanVB;
	LPDIRECT3DINDEXBUFFER9 m_pOceanIB;
	LPDIRECT3DVERTEXDECLARATION9 m_pMeshDecl;
	
	// Color look up 1D texture, height/choppy field, gradient field for normal generating, foam detection
	LPDIRECT3DTEXTURE9		m_pBicolorMap;			// (RGBA8)
	LPDIRECT3DTEXTURE9		m_pHeightMap;			// (ABGR32)
	LPDIRECT3DTEXTURE9		m_pGradientMap;			// (ABGR16)
	// Back buffer for CPU uploading
	LPDIRECT3DTEXTURE9		m_pHeightMapBack;		// (ABGR32)

	LPD3DXEFFECT m_pOceanFX;

	// Only for distinguishing the different callers
	void* m_pCaller;

	// --------------------------------- Rendering routines ---------------------------------

	HRESULT init(OceanParameter& params);
	void renderShaded(KG3DTerrainRender* pRender);
	void renderShaded(/*const CBaseCamera& camera*/);

	void renderWireframe(/*const CBaseCamera& camera*/);
	void renderDepth(/*const CBaseCamera& camera*/);
	void displayBuffer(OceanBufferType type);
    void updateHeightMapNew();

    HRESULT OnLostDevice();
    HRESULT OnResetDevice();

/*
	//---------------------------------- Ripple Code ---------------------------------------

	// The list of ripple touching objects, up to OCEAN_MAX_RIPPLES.
	// Toucher pool.
	FRippleBufferParameter m_Touchers[OCEAN_BUFFER_NUM];
	// Ripple center in world space.
	D3DXVECTOR2 m_RippleCenterArray[OCEAN_BUFFER_NUM];
	// Ripple center in world space, approaching the target point slowly over time.
	LPF_2D m_LPF_Array[OCEAN_BUFFER_NUM];
	// Ripple buffer scroll offsets
	D3DXVECTOR2 m_fDuv_Array[OCEAN_BUFFER_NUM];
	// Time interval
	FLOAT m_DeltaTime, m_DeltaTimePrev;
	// Update: add a switch to disable ripples
	bool m_DisableRipple;

	void initRipple();
	void destroyRipple();
	void updateRipple(FD3DRenderInterface* RI);
	void addRippleDroplet(FD3DRenderInterface* RI);
	void updateRippleCenter();
	// Return value: how many ripples occur at patch(m, n).
	int  updateRippleConstants(int patch_m, int patch_n, D3DXVECTOR4* scale_offset_array, FD3DRenderInterface* RI);
	int  updateRippleConstantsForMesh(AEOceanMesh* ocean_mesh, D3DXVECTOR4* scale_offset_array, FD3DRenderInterface* RI);
	int  getRippleNum()
	{
		int counter = 0;
		for (int i = 0; i < OCEAN_BUFFER_NUM; i++)
			if (m_Touchers[i].buffer_status != RBS_Free)
				counter ++;
		return counter;
	}

	FLOAT* visibilities;

	// ------------------------- Optimization --------------------------
	FLOAT m_max_height, m_min_height;
	void findHeightExtent();
*/

protected:
	FLOAT fSecsPerTick;
	LARGE_INTEGER qwTime, qwLastTime, qwElapsedTime, qwAppTime, qwElapsedAppTime;
	FLOAT fAppTime;

//	FLOAT m_ripple_phase;

	void clearTexture(LPDIRECT3DTEXTURE9 pTex, D3DCOLOR color, UINT width, UINT height);
};

// D3DXEffect pass index
enum RippleFX_Pass
{
	Pass_AddDroplet							= 0,
	Pass_Disperse							= 1,
	Pass_BlurBlend							= 2,	// <------ Merge on PC
	Pass_CalcGradient						= 3,
	Pass_Merge								= 4,
	Pass_Clear								= 5,
};

enum OceanFX_Pass
{
	Pass_TileVS_WavePS						= 0,
	Pass_MeshVS_WavePS						= 1,
	Pass_TileVS_UnderwaterPS				= 2,
	Pass_MeshVS_UnderwaterPS				= 3,
	Pass_TileRippleVS_WaveRipplePS			= 4,
	Pass_MeshRippleVS_WaveRipplePS			= 5,
	Pass_TileRippleVS_UnderwaterRipplePS	= 6,
	Pass_MeshRippleVS_UnderwaterRipplePS	= 7,
	Pass_GradientFolding					= 8,
	Pass_Folding							= 9,
	Pass_TileWireframe						= 10,
	Pass_MeshWireframe						= 11,
	Pass_Distant							= 12,
	Pass_TileVS_ConstantBlackPS				= 13,
	Pass_MeshVS_ConstantBlackPS				= 14,
	Pass_Distant_ConstantBlackPS			= 15,
};

#endif	// _OCEAN_WAVE_H
